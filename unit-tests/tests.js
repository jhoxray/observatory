// Generated by CoffeeScript 1.6.3
(function() {
  var EJSON, Inspect, Meteor, Observatory, TLog, WebApp, chai, should, _ref;

  Meteor = {
    isServer: true,
    isClient: false,
    Collection: function(name) {
      this.name = name;
      return {
        allow: function(fn) {},
        insert: function() {}
      };
    },
    startup: function(fn) {
      return fn.call(this, arguments);
    },
    setInterval: function(fn) {},
    publish: function(name, fn) {}
  };

  EJSON = JSON;

  WebApp = {
    connectHandlers: {
      use: function(name) {}
    }
  };

  Observatory = {
    logger: function() {}
  };

  /*
  if process.env.TESTING is "true"
    MeteorStubs = require('./unit-tests/MeteorStubs.coffee')
    Meteor = MeteorStubs.Meteor
    WebApp = MeteorStubs.WebApp
    Observatory = MeteorStubs.Observatory
    EJSON = MeteorStubs.EJSON
  */


  TLog = (function() {
    TLog._connectLogsBuffer = [];

    TLog._log_http = true;

    TLog.addToLogsBuffer = function(obj) {
      return this._connectLogsBuffer.push(obj);
    };

    TLog.checkConnectLogsBuffer = function() {
      var fullMsg, l, loglevel, msg, options, tl, _i, _len, _ref;
      if (TLog._connectLogsBuffer.length > 0) {
        tl = TLog.getLogger();
        _ref = TLog._connectLogsBuffer;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          l = _ref[_i];
          msg = "" + l.method + " " + l.url + ": " + l.status + " in " + l.responseTime + " ms\n" + l.userAgent + "\n" + l.responseHeader;
          fullMsg = msg + ("\nreferrer: " + (l.referrer != null));
          loglevel = TLog.LOGLEVEL_VERBOSE;
          if (l.status >= 500) {
            loglevel = TLog.LOGLEVEL_FATAL;
          } else {
            if (l.status >= 400) {
              loglevel = TLog.LOGLEVEL_ERROR;
            } else {
              if (l.status >= 300) {
                loglevel = TLog.LOGLEVEL_WARNING;
              }
            }
          }
          options = {
            isServer: true,
            message: msg,
            full_message: fullMsg,
            module: "HTTP",
            timestamp: l.timestamp,
            ip: l.forwardedFor,
            elapsedTime: l.responseTime
          };
          tl._lowLevelLog(loglevel, options, l);
        }
        return TLog._connectLogsBuffer = [];
      }
    };

    TLog._instance = void 0;

    TLog._global_logs = new Meteor.Collection('_observatory_logs');

    TLog.getLogger = function() {
      if (this._instance == null) {
        this._instance = new TLog(TLog.LOGLEVEL_DEBUG, false, true, false);
      }
      return this._instance;
    };

    TLog.LOGLEVEL_FATAL = 0;

    TLog.LOGLEVEL_ERROR = 1;

    TLog.LOGLEVEL_WARNING = 2;

    TLog.LOGLEVEL_INFO = 3;

    TLog.LOGLEVEL_VERBOSE = 4;

    TLog.LOGLEVEL_DEBUG = 5;

    TLog.LOGLEVEL_MAX = 6;

    TLog.limit = 300;

    TLog.LOGLEVEL_NAMES = ["FATAL", "ERROR", "WARNING", "INFO", "VERBOSE", "DEBUG", "MAX"];

    TLog.LOGLEVEL_NAMES_SHORT = ["FTL", "ERR", "WRN", "INF", "VRB", "DBG", "MAX"];

    function TLog(_currentLogLevel, _printToConsole, _log_user, show_warning) {
      var settings, _ref, _ref1;
      this._currentLogLevel = _currentLogLevel;
      this._printToConsole = _printToConsole;
      this._log_user = _log_user != null ? _log_user : true;
      if (show_warning == null) {
        show_warning = true;
      }
      if (TLog._instance != null) {
        throw new Error("Attempted to create another instance of the TLog");
      }
      settings = (_ref = Meteor.settings) != null ? (_ref1 = _ref["public"]) != null ? _ref1.observatorySettings : void 0 : void 0;
      if (settings != null) {
        this._currentLogLevel = TLog[settings.logLevel];
        this._printToConsole = settings.printToConsole;
        this._log_user = settings.logUser;
        this._log_http = settings.logHttp;
      }
      this._logs = TLog._global_logs;
      if (Meteor.isServer) {
        WebApp.connectHandlers.use(Observatory.logger);
        if (!(settings != null ? settings.prohibitAutoPublish : void 0)) {
          Meteor.publish('_observatory_logs', function() {
            return TLog._global_logs.find({}, {
              sort: {
                timestamp: -1
              },
              limit: TLog.limit
            });
          });
        }
        TLog._global_logs.allow({
          insert: function(uid) {
            return true;
          },
          update: function(uid) {
            return false;
          }
        });
      }
      if (Meteor.isClient) {
        Meteor.subscribe('_observatory_logs');
      }
      if (show_warning) {
        this.warn("You should use TLog.getLogger(loglevel, want_to_print) method instead of a constructor! Constructor calls may be removed      in the next versions of the package.");
      }
      this.verbose("Creating logger with level " + TLog.LOGLEVEL_NAMES[this._currentLogLevel] + ", print to console: " + this._printToConsole + ", log user: " + this._log_user, "Observatory");
    }

    TLog.publish = function(func) {
      if (Meteor.isServer) {
        return Meteor.publish('_observatory_logs', function() {
          var canPublish;
          canPublish = func != null ? func(this.userId) : true;
          if (canPublish) {
            return TLog._global_logs.find({}, {
              sort: {
                timestamp: -1
              },
              limit: TLog.limit
            });
          }
        });
      }
    };

    TLog.allowRemove = function(func) {
      var tl;
      tl = TLog.getLogger();
      if (Meteor.isServer) {
        return TLog._global_logs.allow({
          remove: function(uid) {
            tl.warn("Setting allowRemove on the logger to " + func, "Observatory");
            if (func) {
              return func(uid);
            } else {
              return true;
            }
          }
        });
      } else {
        return tl.warn("Tried to set remove permissions to " + func + " on the client", "Observatory");
      }
    };

    TLog.prototype.setOptions = function(loglevel, want_to_print, log_user, log_http) {
      if (want_to_print == null) {
        want_to_print = true;
      }
      if (log_user == null) {
        log_user = true;
      }
      if (log_http == null) {
        log_http = true;
      }
      if ((loglevel >= 0) && (loglevel <= TLog.LOGLEVEL_MAX)) {
        this._currentLogLevel = loglevel;
      }
      this._printToConsole = want_to_print;
      this._log_user = log_user;
      TLog._log_http = log_http;
      return this.verbose("Setting log options with level " + TLog.LOGLEVEL_NAMES[this._currentLogLevel] + ", print to console: " + this._printToConsole + ", log user: " + this._log_user + ", http logging: " + TLog._log_http, "Observatory");
    };

    TLog.prototype.fatal = function(msg, module) {
      return this._log(msg, TLog.LOGLEVEL_FATAL, module);
    };

    TLog.prototype.error = function(msg, module) {
      return this._log(msg, TLog.LOGLEVEL_ERROR, module);
    };

    TLog.prototype.warn = function(msg, module) {
      return this._log(msg, TLog.LOGLEVEL_WARNING, module);
    };

    TLog.prototype.info = function(msg, module) {
      return this._log(msg, TLog.LOGLEVEL_INFO, module);
    };

    TLog.prototype.verbose = function(msg, module) {
      return this._log(msg, TLog.LOGLEVEL_VERBOSE, module);
    };

    TLog.prototype.debug = function(msg, module) {
      return this._log(msg, TLog.LOGLEVEL_DEBUG, module);
    };

    TLog.prototype.insaneVerbose = function(msg, module) {
      return this._log(msg, TLog.LOGLEVEL_MAX, module);
    };

    TLog.prototype.trace = function(error, message, module) {
      var m, msg;
      m = "Error: ";
      if (error.message) {
        m = m + error.message;
      }
      if (error.trace) {
        m = m + " StackTrace: " + error.stack;
      }
      if (error.reason != null) {
        m = m + " Code: " + error.error + " Reason: " + error.reason;
      }
      if (message) {
        msg = message + " | " + m;
      }
      return this._log(msg, TLog.LOGLEVEL_ERROR, module);
    };

    TLog.prototype.dir = function(obj, message, module) {
      var m, methods, mnames, msg, p, pnames, props, _i, _j, _len, _len1;
      msg = message ? message : "Inspecting object:";
      if (obj != null) {
        mnames = Inspect.methods(obj);
        pnames = Inspect.properties(obj);
        methods = [];
        props = [];
        for (_i = 0, _len = mnames.length; _i < _len; _i++) {
          m = mnames[_i];
          methods.push(m);
        }
        for (_j = 0, _len1 = pnames.length; _j < _len1; _j++) {
          p = pnames[_j];
          props.push({
            name: p,
            value: obj[p]
          });
        }
        this.debug(msg, module);
        this._log("Methods: " + EJSON.stringify(methods), TLog.LOGLEVEL_DEBUG, module);
        return this._log("Properties: " + EJSON.stringify(props), TLog.LOGLEVEL_DEBUG, module);
      }
    };

    TLog.prototype.currentLogLevelName = function() {
      return TLog.LOGLEVEL_NAMES[this._currentLogLevel];
    };

    TLog.prototype.logCount = function() {
      return this._logs.find({}).count();
    };

    TLog.prototype._lowLevelLog = function(loglevel, options, customOptions, fn) {
      var e, obj, ts;
      ts = options.timestamp_text ? options.timestamp_text : this._ps(TLog._convertDate(options.timestamp)) + this._ps(TLog._convertTime(options.timestamp));
      obj = {
        isServer: options.isServer || false,
        message: options.message,
        full_message: options.full_message,
        module: options.module,
        loglevel: loglevel,
        timestamp_text: ts,
        timestamp: options.timestamp,
        uid: options.uid,
        user: options.user,
        ip: options.ip,
        elapsedTime: options.elapsedTime,
        customOptions: customOptions
      };
      if (fn) {
        return this._logs.insert(obj, fn);
      } else {
        try {
          return this._logs.insert(obj);
        } catch (_error) {
          e = _error;
          console.log("ERROR while inserting logs from TLog");
          return console.dir(e.stack);
        }
      }
    };

    TLog.prototype._checkUser = function() {
      var err, u, uid, user;
      user = '';
      try {
        uid = this.userId != null ? this.userId : Meteor.userId();
        u = Meteor.users.findOne(uid);
        if (u && u.username) {
          user = u.username;
        } else {
          if (u && u.emails && u.emails[0]) {
            user = u.emails[0].address;
          } else {
            user = uid;
          }
        }
      } catch (_error) {
        err = _error;
      }
      return {
        user: user,
        uid: uid
      };
    };

    TLog.prototype._prepareLogOptions = function(msg, loglevel, module) {
      var options, srv, uid, user, _ref;
      srv = Meteor.isServer;
      if (this._log_user) {
        _ref = this._checkUser(), user = _ref.user, uid = _ref.uid;
      }
      options = {
        isServer: srv,
        message: msg,
        module: module,
        timestamp: new Date,
        uid: uid,
        user: user,
        loglevel: loglevel
      };
      return options;
    };

    TLog.prototype._formatLogMessage = function(o, colorize) {
      var full_message, ts;
      if (colorize == null) {
        colorize = false;
      }
      ts = this._ps(TLog._convertDate(o.timestamp)) + this._ps(TLog._convertTime(o.timestamp));
      full_message = ts + (o.isServer ? "[SERVER]" : "[CLIENT]");
      full_message += o.module ? this._ps(o.module) : "[]";
      full_message += this._ps(TLog.LOGLEVEL_NAMES[o.loglevel]);
      full_message += "[" + o.user + "]";
      full_message += " " + o.message;
      return full_message;
    };

    TLog.prototype._log = function(msg, loglevel, mdl) {
      var options;
      if (loglevel == null) {
        loglevel = TLog.LOGLEVEL_INFO;
      }
      if (loglevel <= this._currentLogLevel) {
        options = this._prepareLogOptions(msg, loglevel, mdl);
        options.full_message = this._formatLogMessage(options);
        this._lowLevelLog(loglevel, options);
        if (this._printToConsole) {
          return console.log(options.full_message);
        }
      }
    };

    TLog.prototype._convertTimestamp = function(timestamp) {
      var st;
      return st = timestamp.getUTCDate() + '/' + timestamp.getUTCMonth() + '/' + timestamp.getUTCFullYear() + ' ' + timestamp.getUTCHours() + ':' + timestamp.getUTCMinutes() + ':' + timestamp.getUTCSeconds() + '.' + timestamp.getUTCMilliseconds();
    };

    TLog._convertDate = function(timestamp) {
      var st;
      return st = timestamp.getUTCDate() + '/' + timestamp.getUTCMonth() + '/' + timestamp.getUTCFullYear();
    };

    TLog._convertTime = function(timestamp, ms) {
      var ts;
      if (ms == null) {
        ms = true;
      }
      ts = timestamp.getUTCHours() + ':' + timestamp.getUTCMinutes() + ':' + timestamp.getUTCSeconds();
      if (ms) {
        ts += '.' + timestamp.getUTCMilliseconds();
      }
      return ts;
    };

    TLog.prototype._ps = function(s) {
      return '[' + s + ']';
    };

    TLog._getLogs = function(sort) {
      if (sort) {
        return this._global_logs.find({}, {
          sort: sort
        });
      } else {
        return this._global_logs.find({}, {
          sort: {
            timestamp: -1
          }
        });
      }
    };

    TLog._clear = function() {
      return this._global_logs.remove({});
    };

    return TLog;

  }).call(this);

  if (Meteor.isServer) {
    Meteor.startup(function() {
      return Meteor.setInterval(function() {
        return TLog.checkConnectLogsBuffer();
      }, 5000);
    });
  }

  Inspect = {
    TYPE_FUNCTION: "function",
    methods: function(obj) {
      var methods, prop, testObj;
      testObj = obj || self;
      methods = [];
      for (prop in testObj) {
        if (typeof testObj[prop] === Inspect.TYPE_FUNCTION && typeof Inspect[prop] !== Inspect.TYPE_FUNCTION) {
          methods.push(prop);
        }
      }
      return methods;
    },
    properties: function(obj) {
      var prop, properties, testObj;
      testObj = obj || self;
      properties = [];
      for (prop in testObj) {
        if (typeof testObj[prop] !== Inspect.TYPE_FUNCTION && typeof Inspect[prop] !== Inspect.TYPE_FUNCTION) {
          properties.push(prop);
        }
      }
      return properties;
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    if ((_ref = module.exports) != null) {
      _ref.TLog = TLog;
    }
  }

  (typeof exports !== "undefined" && exports !== null ? exports : this).TLog = TLog;

  (typeof exports !== "undefined" && exports !== null ? exports : this).Inspect = Inspect;

  chai = require('chai');

  should = chai.should();

  describe('TLog class', function() {
    var tl;
    tl = TLog.getLogger();
    it('should be visible, have the global logs collection and log http by default', function() {
      TLog.should.exist;
      TLog._global_logs.should.exist;
      TLog._log_http.should.be["true"];
      return TLog._connectLogsBuffer.should.be.empty;
    });
    it('should return the default logger with correct defaults', function() {
      tl.should.exist;
      tl.should.be.an["instanceof"](TLog);
      tl._currentLogLevel.should.equal(TLog.LOGLEVEL_DEBUG);
      tl._log_user.should.be["true"];
      return tl._printToConsole.should.be["false"];
    });
    it('should add http logs to buffer and clean them after processing', function() {
      var httpLog;
      httpLog = {
        timestamp: new Date
      };
      TLog.addToLogsBuffer(httpLog);
      TLog._connectLogsBuffer.length.should.equal(1);
      TLog._connectLogsBuffer[0].should.equal(httpLog);
      TLog.checkConnectLogsBuffer();
      return TLog._connectLogsBuffer.should.be.empty;
    });
    return describe('Logging methods:', function() {
      return it("should call methods with all log levels", function() {
        var i, m, _i, _j, _len, _len1, _ref1, _ref2, _results;
        _ref1 = ['fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'insaneVerbose'];
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          m = _ref1[i];
          tl.should.respondTo(m);
          tl[m]("Logging " + TLog.LOGLEVEL_NAMES[i] + " message", "TESTS");
        }
        _ref2 = ['trace', 'dir'];
        _results = [];
        for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
          m = _ref2[i];
          tl.should.respondTo(m);
          _results.push(tl[m](new Error("Test Error"), "Message for " + m));
        }
        return _results;
      });
    });
  });

}).call(this);
